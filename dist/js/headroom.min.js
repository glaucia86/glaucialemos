/*!
 * headroom.js v0.9.3 - Give your page some headroom. Hide your header until you need it
 * Copyright (c) 2016 Nick Williams - http://wicky.nillia.ms/headroom.js
 * License: MIT
 */

!(function(a, b) {
  typeof define === "function" && define.amd
    ? define([], b)
    : typeof exports === "object"
    ? (module.exports = b())
    : (a.Headroom = b());
})(this, () => {
  function a(a) {
    (this.callback = a), (this.ticking = !1);
  }
  function b(a) {
    return a && typeof window !== "undefined" && (a === window || a.nodeType);
  }
  function c(a) {
    if (arguments.length <= 0) {
      throw new Error("Missing arguments in extend function");
    }
    let d;

    let e;

    const f = a || {};
    for (e = 1; e < arguments.length; e++) {
      const g = arguments[e] || {};
      for (d in g) {
        typeof f[d] !== "object" || b(f[d])
          ? (f[d] = f[d] || g[d])
          : (f[d] = c(f[d], g[d]));
      }
    }
    return f;
  }
  function d(a) {
    return a === Object(a) ? a : { down: a, up: a };
  }
  function e(a, b) {
    (b = c(b, e.options)),
      (this.lastKnownScrollY = 0),
      (this.elem = a),
      (this.tolerance = d(b.tolerance)),
      (this.classes = b.classes),
      (this.offset = b.offset),
      (this.scroller = b.scroller),
      (this.initialised = !1),
      (this.onPin = b.onPin),
      (this.onUnpin = b.onUnpin),
      (this.onTop = b.onTop),
      (this.onNotTop = b.onNotTop),
      (this.onBottom = b.onBottom),
      (this.onNotBottom = b.onNotBottom);
  }
  const f = {
    bind: !!function() {}.bind,
    classList: "classList" in document.documentElement,
    rAF: !!(
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame
    )
  };
  return (
    (window.requestAnimationFrame =
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame),
    (a.prototype = {
      constructor: a,
      update() {
        this.callback && this.callback(), (this.ticking = !1);
      },
      requestTick() {
        this.ticking ||
          (requestAnimationFrame(
            this.rafCallback || (this.rafCallback = this.update.bind(this))
          ),
          (this.ticking = !0));
      },
      handleEvent() {
        this.requestTick();
      }
    }),
    (e.prototype = {
      constructor: e,
      init() {
        return e.cutsTheMustard
          ? ((this.debouncer = new a(this.update.bind(this))),
            this.elem.classList.add(this.classes.initial),
            setTimeout(this.attachEvent.bind(this), 100),
            this)
          : void 0;
      },
      destroy() {
        const a = this.classes;
        (this.initialised = !1),
          this.elem.classList.remove(
            a.unpinned,
            a.pinned,
            a.top,
            a.notTop,
            a.initial
          ),
          this.scroller.removeEventListener("scroll", this.debouncer, !1);
      },
      attachEvent() {
        this.initialised ||
          ((this.lastKnownScrollY = this.getScrollY()),
          (this.initialised = !0),
          this.scroller.addEventListener("scroll", this.debouncer, !1),
          this.debouncer.handleEvent());
      },
      unpin() {
        const a = this.elem.classList;

        const b = this.classes;
        (!a.contains(b.pinned) && a.contains(b.unpinned)) ||
          (a.add(b.unpinned),
          a.remove(b.pinned),
          this.onUnpin && this.onUnpin.call(this));
      },
      pin() {
        const a = this.elem.classList;

        const b = this.classes;
        a.contains(b.unpinned) &&
          (a.remove(b.unpinned),
          a.add(b.pinned),
          this.onPin && this.onPin.call(this));
      },
      top() {
        const a = this.elem.classList;

        const b = this.classes;
        a.contains(b.top) ||
          (a.add(b.top),
          a.remove(b.notTop),
          this.onTop && this.onTop.call(this));
      },
      notTop() {
        const a = this.elem.classList;

        const b = this.classes;
        a.contains(b.notTop) ||
          (a.add(b.notTop),
          a.remove(b.top),
          this.onNotTop && this.onNotTop.call(this));
      },
      bottom() {
        const a = this.elem.classList;

        const b = this.classes;
        a.contains(b.bottom) ||
          (a.add(b.bottom),
          a.remove(b.notBottom),
          this.onBottom && this.onBottom.call(this));
      },
      notBottom() {
        const a = this.elem.classList;

        const b = this.classes;
        a.contains(b.notBottom) ||
          (a.add(b.notBottom),
          a.remove(b.bottom),
          this.onNotBottom && this.onNotBottom.call(this));
      },
      getScrollY() {
        return void 0 !== this.scroller.pageYOffset
          ? this.scroller.pageYOffset
          : void 0 !== this.scroller.scrollTop
          ? this.scroller.scrollTop
          : (
              document.documentElement ||
              document.body.parentNode ||
              document.body
            ).scrollTop;
      },
      getViewportHeight() {
        return (
          window.innerHeight ||
          document.documentElement.clientHeight ||
          document.body.clientHeight
        );
      },
      getElementPhysicalHeight(a) {
        return Math.max(a.offsetHeight, a.clientHeight);
      },
      getScrollerPhysicalHeight() {
        return this.scroller === window || this.scroller === document.body
          ? this.getViewportHeight()
          : this.getElementPhysicalHeight(this.scroller);
      },
      getDocumentHeight() {
        const a = document.body;

        const b = document.documentElement;
        return Math.max(
          a.scrollHeight,
          b.scrollHeight,
          a.offsetHeight,
          b.offsetHeight,
          a.clientHeight,
          b.clientHeight
        );
      },
      getElementHeight(a) {
        return Math.max(a.scrollHeight, a.offsetHeight, a.clientHeight);
      },
      getScrollerHeight() {
        return this.scroller === window || this.scroller === document.body
          ? this.getDocumentHeight()
          : this.getElementHeight(this.scroller);
      },
      isOutOfBounds(a) {
        const b = a < 0;

        const c =
          a + this.getScrollerPhysicalHeight() > this.getScrollerHeight();
        return b || c;
      },
      toleranceExceeded(a, b) {
        return Math.abs(a - this.lastKnownScrollY) >= this.tolerance[b];
      },
      shouldUnpin(a, b) {
        const c = a > this.lastKnownScrollY;

        const d = a >= this.offset;
        return c && d && b;
      },
      shouldPin(a, b) {
        const c = a < this.lastKnownScrollY;

        const d = a <= this.offset;
        return (c && b) || d;
      },
      update() {
        const a = this.getScrollY();

        const b = a > this.lastKnownScrollY ? "down" : "up";

        const c = this.toleranceExceeded(a, b);
        this.isOutOfBounds(a) ||
          (a <= this.offset ? this.top() : this.notTop(),
          a + this.getViewportHeight() >= this.getScrollerHeight()
            ? this.bottom()
            : this.notBottom(),
          this.shouldUnpin(a, c)
            ? this.unpin()
            : this.shouldPin(a, c) && this.pin(),
          (this.lastKnownScrollY = a));
      }
    }),
    (e.options = {
      tolerance: { up: 0, down: 0 },
      offset: 0,
      scroller: window,
      classes: {
        pinned: "headroom--pinned",
        unpinned: "headroom--unpinned",
        top: "headroom--top",
        notTop: "headroom--not-top",
        bottom: "headroom--bottom",
        notBottom: "headroom--not-bottom",
        initial: "headroom"
      }
    }),
    (e.cutsTheMustard =
      typeof f !== "undefined" && f.rAF && f.bind && f.classList),
    e
  );
});
